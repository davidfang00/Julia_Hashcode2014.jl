var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Julia_Hashcode2014","category":"page"},{"location":"#Julia_Hashcode2014","page":"Home","title":"Julia_Hashcode2014","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Julia_Hashcode2014.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Julia_Hashcode2014]","category":"page"},{"location":"#Julia_Hashcode2014.AdjacencyGraph","page":"Home","title":"Julia_Hashcode2014.AdjacencyGraph","text":"AdjacencyGraph\n\nStore a city in the form of an weighted adjacency graph. Weights are based on length. \n\nFields\n\noutneighbors::Vector{Vector{Int}}: junctions\nweights::Vector{Vector{Float64}}: weights based on length for each street.\ntimes::Dict{Tuple{Int,Int},Float64}: the time it takes to travel a street.\n\n\n\n\n\n","category":"type"},{"location":"#Julia_Hashcode2014.create_graph-Tuple{HashCode2014.City}","page":"Home","title":"Julia_Hashcode2014.create_graph","text":"Create an [`AdjacencyGraph`](@ref) based on a city.\n\n\n\n\n\n","category":"method"},{"location":"#Julia_Hashcode2014.edge_time-Tuple{AdjacencyGraph, Any, Any}","page":"Home","title":"Julia_Hashcode2014.edge_time","text":"edge_time(g, u, v)\n\nReturns the time it takes to traverse the path (u, v) based on an AdjacencyGraph g.\n\n\n\n\n\n","category":"method"},{"location":"#Julia_Hashcode2014.edge_weight-Tuple{AdjacencyGraph, Any, Any}","page":"Home","title":"Julia_Hashcode2014.edge_weight","text":"edge_weight(g, u, v)\n\nReturns the distance that the path (u, v) will traverse based on an AdjacencyGraph g.\n\n\n\n\n\n","category":"method"},{"location":"#Julia_Hashcode2014.greedy-Tuple{HashCode2014.City}","page":"Home","title":"Julia_Hashcode2014.greedy","text":"greedy(city)\n\nImplements a greedy algorithm for routing. Cars will take turns going down one street at a time based on the follow criteria:\n\nCheck if the neighboring node has been visited. If not, take the maximum distance path while obeying time constraints.\nIf a neighboring node has been visited, check the next node.\nIf all neighboring nodes have been visited, choose a random path to go down while obeying the time constraint.\n\n\n\n\n\n","category":"method"},{"location":"#Julia_Hashcode2014.outneighbors-Tuple{AdjacencyGraph, Any}","page":"Home","title":"Julia_Hashcode2014.outneighbors","text":"outneighbors(g, u)\n\nReturns the outneighbors of node u based on an AdjacencyGraph g.\n\n\n\n\n\n","category":"method"}]
}
